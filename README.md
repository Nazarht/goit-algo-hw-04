## Аналіз продуктивності сортувань: вставками, злиттям та Timsort

На базі наданого виводу бенчмарків порівняно три алгоритми: сортування вставками, сортування злиттям та вбудований у Python `sorted`/`list.sort()` (Timsort). Оцінювалась медіана часу з 5 виконаннь на наборах даних: випадкові, відсортовані, зворотно відсортовані, майже відсортовані (≈5% перестановок), для розмірів до 100 000 елементів.

### Підсумки вимірювань
- **Timsort — стабільно найшвидший** на всіх наборах.
- **Insertion sort vs Timsort**: приблизно у **13–21 раз** повільніший на більшості розмірів до 50k (наприклад, random 5k — ~19.8×, reversed 10k — ~20.8×, nearly_sorted 10k — ~17.5×).
- **Merge sort vs Timsort**: зазвичай у **170–350 разів** повільніший на відсортованих/зворотних і майже відсортованих масивах (наприклад, reversed 50k — ~344.8×, sorted 100k — ~348.8×, nearly_sorted 50k — ~357.9×). Водночас на великих випадкових даних спостерігається менший розрив: **random 100k — ~15×**.

### Інтерпретація результатів
- **Timsort** комбінує злиття та вставки: виявляє вже впорядковані масиви, ефективно їх зливає, а на малих підмасивах використовує вставки з дуже малою константою часу. Це дає перевагу на практично всіх реалістичних даних, особливо коли вони частково впорядковані.
- **Merge sort** має склдність \(O(n * log n)\), але програє Timsort в реальних експериментах. На відсортованих/зворотних/майже відсортованих даних різниця сягає сотень разів. На великих випадкових даних різниця менше, але Timsort все одно швидший.
- **Insertion sort** теоретично \(O(n^2)\) у гіршому випадку, але дуже швидкий на майже відсортованих масивах. У наведених вимірюваннях він стабільно повільніший за Timsort (~13–21×), проте часто випереджає merge на невеликих задачах завдяки тому що швидко проходить через вже відсортовані частини.

### Таблиці результатів

#### Random

| n | algo | median_time_s |
|---:|:---:|---:|
| 1000 | insertion | 0.000072 |
| 1000 | merge | 0.000984 |
| 1000 | timsort | 0.000004 |
| 5000 | insertion | 0.000379 |
| 5000 | merge | 0.005908 |
| 5000 | timsort | 0.000019 |
| 10000 | insertion | 0.000757 |
| 10000 | merge | 0.012561 |
| 10000 | timsort | 0.000046 |
| 50000 | insertion | 0.003860 |
| 50000 | merge | 0.073560 |
| 50000 | timsort | 0.000219 |
| 100000 | merge | 0.184085 |
| 100000 | timsort | 0.012278 |

#### Sorted

| n | algo | median_time_s |
|---:|:---:|---:|
| 1000 | insertion | 0.000074 |
| 1000 | merge | 0.000968 |
| 1000 | timsort | 0.000004 |
| 5000 | insertion | 0.000378 |
| 5000 | merge | 0.005814 |
| 5000 | timsort | 0.000022 |
| 10000 | insertion | 0.000760 |
| 10000 | merge | 0.012416 |
| 10000 | timsort | 0.000044 |
| 50000 | insertion | 0.003899 |
| 50000 | merge | 0.069832 |
| 50000 | timsort | 0.000220 |
| 100000 | merge | 0.149543 |
| 100000 | timsort | 0.000429 |

#### Reversed

| n | algo | median_time_s |
|---:|:---:|---:|
| 1000 | insertion | 0.000072 |
| 1000 | merge | 0.000968 |
| 1000 | timsort | 0.000006 |
| 5000 | insertion | 0.000376 |
| 5000 | merge | 0.006036 |
| 5000 | timsort | 0.000021 |
| 10000 | insertion | 0.000754 |
| 10000 | merge | 0.012474 |
| 10000 | timsort | 0.000036 |
| 50000 | insertion | 0.003817 |
| 50000 | merge | 0.071238 |
| 50000 | timsort | 0.000207 |

#### Nearly sorted (~5% swaps)

| n | algo | median_time_s |
|---:|:---:|---:|
| 1000 | insertion | 0.000071 |
| 1000 | merge | 0.000980 |
| 1000 | timsort | 0.000003 |
| 5000 | insertion | 0.000374 |
| 5000 | merge | 0.005817 |
| 5000 | timsort | 0.000022 |
| 10000 | insertion | 0.000759 |
| 10000 | merge | 0.012543 |
| 10000 | timsort | 0.000043 |
| 50000 | insertion | 0.003785 |
| 50000 | merge | 0.069924 |
| 50000 | timsort | 0.000195 |
| 100000 | merge | 0.174694 |
| 100000 | timsort | 0.003184 |

#### Відносна швидкість (algo_time / timsort_time)

| dataset | n | algo | ratio |
|:--|---:|:---:|---:|
| random | 1000 | insertion | 18.76 |
| random | 1000 | merge | 256.66 |
| random | 5000 | insertion | 19.79 |
| random | 5000 | merge | 308.92 |
| random | 10000 | insertion | 16.62 |
| random | 10000 | merge | 275.80 |
| random | 50000 | insertion | 17.66 |
| random | 50000 | merge | 336.59 |
| random | 100000 | merge | 14.99 |
| sorted | 1000 | insertion | 17.64 |
| sorted | 1000 | merge | 232.31 |
| sorted | 5000 | insertion | 17.03 |
| sorted | 5000 | merge | 261.79 |
| sorted | 10000 | insertion | 17.39 |
| sorted | 10000 | merge | 284.06 |
| sorted | 50000 | insertion | 17.71 |
| sorted | 50000 | merge | 317.24 |
| sorted | 100000 | merge | 348.75 |
| reversed | 1000 | insertion | 12.74 |
| reversed | 1000 | merge | 172.09 |
| reversed | 5000 | insertion | 18.25 |
| reversed | 5000 | merge | 293.23 |
| reversed | 10000 | insertion | 20.81 |
| reversed | 10000 | merge | 344.12 |
| reversed | 50000 | insertion | 18.47 |
| reversed | 50000 | merge | 344.77 |
| nearly_sorted | 1000 | insertion | 20.36 |
| nearly_sorted | 1000 | merge | 279.88 |
| nearly_sorted | 5000 | insertion | 16.67 |
| nearly_sorted | 5000 | merge | 259.49 |
| nearly_sorted | 10000 | insertion | 17.51 |
| nearly_sorted | 10000 | merge | 289.46 |
| nearly_sorted | 50000 | insertion | 19.37 |
| nearly_sorted | 50000 | merge | 357.90 |
| nearly_sorted | 100000 | merge | 54.87 |

### Висновки
- **Поєднання вставок і злиття в Timsort забезпечує значну практичну перевагу**: від десятків до сотень разів швидше за merge sort і суттєво швидше за insertion sort.

### Відтворення
Запустити бенчмарк:

```bash
python3 bench_sorting.py
```


